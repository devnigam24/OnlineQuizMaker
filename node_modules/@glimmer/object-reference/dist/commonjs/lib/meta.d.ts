import { MetaOptions } from './types';
import { Dict, HasGuid, Set } from '@glimmer/util';
import { PathReferenceFactory, Meta as IMeta, RootReference as IRootReference } from './types';
import { PathReference as IPathReference } from '@glimmer/reference';
import { InnerReferenceFactory } from './references/descriptors';
export declare const CLASS_META = "df8be4c8-4e89-44e2-a8f9-550c8dacdca7";
declare class Meta implements IMeta, HasGuid {
    static for(obj: any): IMeta;
    static exists(obj: any): boolean;
    static metadataForProperty(key: string): any;
    private object;
    private RootReferenceFactory;
    private DefaultPathReferenceFactory;
    private rootCache;
    private references;
    _guid: any;
    protected slots: Dict<any>;
    protected referenceTypes: Dict<InnerReferenceFactory<any>>;
    protected propertyMetadata: Dict<any>;
    constructor(object: any, {RootReferenceFactory, DefaultPathReferenceFactory}: MetaOptions);
    addReference(property: string, reference: IPathReference<any> & HasGuid): void;
    addReferenceTypeFor(property: string, type: PathReferenceFactory<any>): void;
    referenceTypeFor(property: string): InnerReferenceFactory<any>;
    removeReference(property: string, reference: IPathReference<any> & HasGuid): void;
    getReferenceTypes(): Dict<InnerReferenceFactory<any>>;
    referencesFor(property: string): Set<IPathReference<any>>;
    getSlots(): Dict<any>;
    root(): IRootReference<any>;
}
export default Meta;
export declare function metaFor(obj: any): IMeta;
