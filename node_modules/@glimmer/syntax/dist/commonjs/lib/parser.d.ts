/// <reference types="handlebars" />
import { NodeVisitor } from "./traversal/traverse";
import { BaseNode } from "./types/nodes";
import { EventedTokenizer } from "simple-html-tokenizer";
import { Program } from "./types/nodes";
export declare const syntax: {
    parse: (html: string | hbs.AST.Program, options?: any) => Program;
    builders: {
        mustache: (path: any, params?: any, hash?: any, raw?: any, loc?: any) => {
            type: string;
            path: any;
            params: any;
            hash: any;
            escaped: boolean;
            loc: {
                source: any;
                start: any;
                end: any;
            };
        };
        block: (path: any, params?: any, hash?: any, program?: any, inverse?: any, loc?: any) => {
            type: string;
            path: any;
            params: any;
            hash: any;
            program: any;
            inverse: any;
            loc: {
                source: any;
                start: any;
                end: any;
            };
        };
        partial: (name: any, params: any, hash: any, indent: any) => {
            type: string;
            name: any;
            params: any;
            hash: any;
            indent: any;
        };
        comment: (value: any, loc?: any) => {
            type: string;
            value: any;
            loc: {
                source: any;
                start: any;
                end: any;
            };
        };
        mustacheComment: (value: any, loc?: any) => {
            type: string;
            value: any;
            loc: {
                source: any;
                start: any;
                end: any;
            };
        };
        element: (tag: any, attributes?: any, modifiers?: any, children?: any, comments?: any, loc?: any) => {
            type: string;
            tag: any;
            attributes: any;
            blockParams: any[];
            modifiers: any;
            comments: any;
            children: any;
            loc: {
                source: any;
                start: any;
                end: any;
            };
        };
        elementModifier: (path: any, params?: any, hash?: any, loc?: any) => {
            type: string;
            path: any;
            params: any;
            hash: any;
            loc: {
                source: any;
                start: any;
                end: any;
            };
        };
        attr: (name: any, value: any, loc?: any) => {
            type: string;
            name: any;
            value: any;
            loc: {
                source: any;
                start: any;
                end: any;
            };
        };
        text: (chars?: any, loc?: any) => {
            type: string;
            chars: any;
            loc: {
                source: any;
                start: any;
                end: any;
            };
        };
        sexpr: (path: any, params?: any, hash?: any, loc?: any) => {
            type: string;
            path: any;
            params: any;
            hash: any;
            loc: {
                source: any;
                start: any;
                end: any;
            };
        };
        path: (original: any, loc?: any) => any;
        string: (value: any) => {
            type: string;
            value: any;
            original: any;
        };
        boolean: (value: any) => {
            type: string;
            value: any;
            original: any;
        };
        number: (value: any) => {
            type: string;
            value: any;
            original: any;
        };
        undefined: () => {
            type: string;
            value: any;
            original: any;
        };
        null: () => {
            type: string;
            value: any;
            original: any;
        };
        concat: (parts: any) => {
            type: string;
            parts: any;
        };
        hash: (pairs?: any) => {
            type: string;
            pairs: any;
        };
        pair: (key: any, value: any) => {
            type: string;
            key: any;
            value: any;
        };
        program: (body?: any, blockParams?: any, loc?: any) => {
            type: string;
            body: any;
            blockParams: any;
            loc: {
                source: any;
                start: any;
                end: any;
            };
        };
        loc: {
            (loc: {
                source: any;
                start: any;
                end: any;
            }): {
                source: any;
                start: any;
                end: any;
            };
            (startLine: any, startColumn: any, endLine?: any, endColumn?: any, source?: any): {
                source: any;
                start: any;
                end: any;
            };
        };
        pos: (line: any, column: any) => {
            line: number;
            column: number;
        };
    };
    print: (ast: any) => string;
    traverse: (node: BaseNode, visitor: NodeVisitor) => void;
    Walker: (order?: any) => void;
};
export declare function preprocess(html: string | hbs.AST.Program, options?: any): Program;
export declare class Parser {
    private elementStack;
    private options;
    private source;
    currentAttribute: any;
    currentNode: any;
    tokenizer: EventedTokenizer;
    constructor(source: any, options?: Object);
    acceptNode(node: hbs.AST.Program): Program;
    currentElement(): Object;
    sourceForMustache(mustache: any): string;
}
